title,heading,content,tokens
GCP Cloud Run,Summary,"Cloud Run is a managed compute platform that lets you run containers directly on top of Google's scalable infrastructure. ",22
GCP Cloud Run,Deploying Code on Cloud Run,"You can deploy code written in any programming language on Cloud Run if you can build a container image from it. In fact, building container images is optional. If you're using Go, Node.js, Python, Java, .NET Core, or Ruby, you can use the source-based deployment option that builds the container for you, using the best practices for the language you're using. ",80
GCP Cloud Run,Building Full-Featured Applications,"Google has built Cloud Run to work well together with other services on Google Cloud, so you can build full-featured applications. ",27
GCP Cloud Run,Increasing Developer Productivity,"Cloud Run allows developers to spend their time writing their code, and very little time operating, configuring, and scaling their Cloud Run service. You don't have to create a cluster or manage infrastructure in order to be productive with Cloud Run. ",49
GCP Cloud Run,Services and jobs: two ways to run your code ,"On Cloud Run, your code can either run continuously as a service or as a job. Both services and jobs run in the same environment and can use the same integrations with other services on Google Cloud. ",42
GCP Cloud Run,Cloud Run services ,"A Cloud Run service provides you with the infrastructure required to run a reliable HTTPS endpoint. Your responsibility is to make sure your code listens on a TCP port and handles HTTP requests. ",36
GCP Cloud Run,Unique HTTPS endpoint for every service ,"Every Cloud Run service is provided with an HTTPS endpoint on a unique subdomain of the *.run.app domain – and you can configure custom domains as well. Cloud Run manages TLS for you, and includes support for WebSockets, HTTP/2 (end-to-end), and gRPC (end-to-end). ",69
GCP Cloud Run,Fast request-based auto scaling ,"Cloud Run is built to rapidly scale out to handle all incoming requests. A service can rapidly scale up to one thousand container instances, or even more if you request a quota increase. If demand decreases, Cloud Run removes idle containers. If you're concerned about costs or overloading downstream systems, you can limit the maximum number of instances. ",68
GCP Cloud Run,Built-in traffic management ,"Every deployment creates a new immutable revision. You can route incoming traffic to the latest revision, roll back to a previous revision, or split traffic to multiple revisions at the same time, to perform a gradual rollout. This is useful if you want to reduce the risk of deploying a new revision. You can start with sending 1% of requests to a new revision, and increase that percentage while monitoring telemetry. ",82
GCP Cloud Run,Private and public services ,"A Cloud Run service can be reachable from the internet, or you can restrict access in three ways: Specify an access policy using Cloud IAM; Use ingress settings to restrict network access. This is useful if you want to allow only internal traffic from the VPC and internal services; Allow only authenticated users with Cloud Identity-Aware Proxy (IAP). You can front a Cloud Run service with a Content Delivery Network (CDN) to serve cacheable assets from an edge location closer to clients. Both Firebase Hosting and Cloud CDN provide this capability.",116
GCP Cloud Run,Scale to zero and minimum instances ,"Cloud Run adds and removes container instances automatically to handle all incoming requests. If there are no incoming requests to your service, even the last remaining container instance will be removed. This behavior is commonly referred to as scale to zero. If there are no active container instances, a new container instance is created on-demand as soon as a request comes in. This negatively impacts the response time for these first requests, depending on how fast your container becomes ready to handle requests. To make sure your service doesn't scale scale to zero instances, you can configure Cloud Run to keep a minimum amount of container instances active. ",122
GCP Cloud Run,Pay-per-use pricing for services ,"Scale to zero is attractive for economic reasons since you're charged for the CPU and memory allocated to a container instance with a granularity of 100ms. If you don't configure minimum instances, you're not charged if your service is not used. ",50
GCP Cloud Run,Two pricing models ,"Request-based : If a container instance is not processing requests, the CPU is not allocated and you're not charged. Additionally, you pay a per-request fee. Instance-based : You're charged for the entire lifetime of a container instance and the CPU is always allocated. There's no per-request fee. ",66
GCP Cloud Run,A disposable container filesystem ,"Container instances on Cloud Run are disposable. Every container has an in-memory, writable filesystem overlay, which is not persisted if the container shuts down. Cloud Run decides independently when to stop sending requests to an instance and shut it down, for example when scaling in. ",55
GCP Cloud Run,When to use Cloud Run services ,"Cloud Run services are great for code that handles requests or events. Example use cases include: Websites and web applications, APIs and microservices, Streaming data processing .",33
GCP Cloud Run,Websites and web applications ,"Build your web app using your favorite stack, access your SQL database, and render dynamic HTML pages. ",21
GCP Cloud Run,APIs and microservices ,"You can build a REST API, or a GraphQL API or private microservices that communicate over HTTP or gRPC. ",26
GCP Cloud Run,Streaming data processing  ,"Cloud Run services can receive messages from Pub/Sub push subscriptions and events from Eventarc. ",19
GCP Cloud Run,Cloud Run Jobs ,"If your code performs work and then stops (a script is a good example), you can use a Cloud Run job to run your code. You can execute a job from the command line using the gcloud CLI, schedule a recurring job, or run it as part of a workflow. ",58
GCP Cloud Run,Array jobs are a faster way to run jobs ,"A job can start one container instance to run your code — that's a common way to run a script or a tool. However, you can also start many identical, independent container instances in parallel, that is, an array job. Array jobs are a faster way to process jobs that can be split into multiple independent tasks. For example, if you are reading 1,000 images from Cloud Storage to resize and crop them, processing them consecutively will be slower than processing them all at the same time with many container instances. ",106
GCP Cloud Run,When to use Cloud Run jobs ,"Cloud Run jobs are well-suited to run code that performs work (a job) and quits when the work is done. Here are a few examples: Script or tool, Array job, Scheduled job.",44
GCP Cloud Run,Script or tool ,"Run a script to perform database migrations or other operational tasks. ",14
GCP Cloud Run,Array job ,"Perform highly parallelized processing of all files in a Cloud Storage bucket. ",16
GCP Cloud Run,Scheduled job ,"Create and send invoices at regular intervals, or save the results of a database query as XML and upload the file every few hours. ",29
GCP Cloud Run,Cloud Run integrations ,"Cloud Run integrates with the broader ecosystem of Google Cloud, which enables you to build full-featured applications. ",23
GCP Cloud Run,Essential integrations include ,"Data storage, Logging and error reporting, Service identity, Continuous delivery, Private networking, Google Cloud APIs, Background tasks.",25
GCP Cloud Run,Data storage ,"Cloud Run integrates with Cloud SQL (managed MySQL, PostgreSQL, and SQL Server), Memorystore (managed Redis and Memcached), Firestore, Cloud Spanner, Cloud Storage, and more. Refer to Data storage for a complete list. ",51
GCP Cloud Run,Logging and error reporting ,"Container logs are automatically ingested by Cloud Logging. If there are exceptions in the logs, Error Reporting aggregates them, and then notifies you. The following languages are supported: Go, Java, Node.js, PHP, Python, Ruby, and .NET. ",55
GCP Cloud Run,Service identity ,"Every Cloud Run revision is linked to a service account, and the Google Cloud client libraries transparently use this service account to authenticate with Google Cloud APIs. ",32
GCP Cloud Run,Continuous delivery ,"If you store your source code in GitHub, Bitbucket, or Cloud Source Repositories, you can configure Cloud Run to automatically deploy new commits. ",31
GCP Cloud Run,Private networking ,"Cloud Run container instances can reach resources in the Virtual Private Cloud (VPC) network through the serverless VPC access connector. This is how your service can connect with Compute Engine virtual machines or products based on Compute Engine, such as Google Kubernetes Engine or Memorystore. ",60
GCP Cloud Run,Google Cloud APIs ,"Your service's code transparently authenticates with Google Cloud APIs. Examples include the AI and Machine Learning APIs, such as the Cloud Vision API, Speech-to- Text API, AutoML Natural Language API, Cloud Translation API, and many more. ",51
GCP Cloud Run,Background tasks ,"If you want to schedule code to run later or immediately after returning a web request, Cloud Run works well together with Cloud Tasks to provide scalable and reliable asynchronous execution. ",35
GCP Cloud Run,Services or jobs must be packaged in a container image ,"In order for your service or job to be deployable to Cloud Run, you must package it in a container image. In case you're not familiar with containers, here's a short conceptual introduction. A container image is a package with everything your service needs to run. That includes build artifacts, assets, system packages, and (optionally) a runtime. This makes a containerized application inherently portable – it runs anywhere a container can run. Examples of build artifacts include compiled binaries or script files, and examples of runtimes are the Node.js JavaScript runtime, or a Java virtual machine (JVM). ",123
GCP Cloud Run,container image,"A container image is a package with everything your service needs to run. That includes build artifacts, assets, system packages, and (optionally) a runtime. This makes a containerized application inherently portable – it runs anywhere a container can run. Examples of build artifacts include compiled binaries or script files, and examples of runtimes are the Node.js JavaScript runtime, or a Java virtual machine (JVM). ",83
